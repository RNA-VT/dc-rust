use core::str;
use anyhow::{Result,bail};
use esp_idf_svc::{eventloop::EspSystemEventLoop, hal::prelude::*,http::server::*};
use log::info;
use wifi::wifi;
use dc;

#[toml_cfg::toml_config]
struct Config {
    #[default("")]
    wifi_ssid: &'static str,
    #[default("")]
    wifi_psk: &'static str,
}

fn main() -> Result<()> {
    // It is necessary to call this function once. Otherwise, some patches to the runtime
    // implemented by esp-idf-sys might not link properly. See https://github.com/esp-rs/esp-idf-template/issues/71
    esp_idf_svc::sys::link_patches();

    // Bind the log crate to the ESP Logging facilities
    esp_idf_svc::log::EspLogger::initialize_default();

    let peripherals = Peripherals::take().unwrap();
    let sysloop = EspSystemEventLoop::take()?;

    info!("I'm a Relay!");
    info!("Connecting to Wi-Fi...");

    // Load Wi-Fi Config
    // The constant `CONFIG` is auto-generated by `toml_config`.
    let app_config = CONFIG;

    // Connect to the Wi-Fi network
    let _wifi = match wifi(
        app_config.wifi_ssid,
        app_config.wifi_psk,
        peripherals.modem,
        sysloop,
    ) {
        Ok(inner) => {
            info!("Wi-Fi: Connection Succeeded!");
            inner
        }
        Err(err) => {
            info!("Wi-Fi: Connection Failed.");
            bail!("Could not connect to Wi-Fi network: {:?}", err)
        }
    };

    let mut server = EspHttpServer::new(&Configuration::default())?;

    server = match dc::server(server) {
        Some(server) => {
            info!("DC Server Successfully Started.");
            server
        }
        None => {
            info!("!!!ERROR!!!");
            bail!("DC Server Failed to Start.");
        }
    };

    server.fn_handler("/on", Method::Post, |_request| {Ok(())}).expect("Failed to create /on Handler");
    server.fn_handler("/off", Method::Post, |_request| {Ok(())}).expect("Failed to create /off Handler");

    loop {
        info!("Blue!");
        info!("Doing Things!");
        std::thread::sleep(std::time::Duration::from_secs(1));
        info!("Green!");
        std::thread::sleep(std::time::Duration::from_secs(1));

    }


}
